defmodule Peque.WAL do
  @moduledoc "WAL log for queues."

  alias Peque.Queue

  @enforce_keys [:dets]
  defstruct [
    :dets,
    buffer: :queue.new(),
    left_id: 1,
    right_id: 1,
    next_ack_id: 1,
    insert_buf: %{},
    del_buf: []
  ]

  @type t :: %__MODULE__{
          dets: :dets.tab_name(),
          left_id: id,
          right_id: id,
          next_ack_id: id,
          insert_buf: %{optional(id) => Queue.message()},
          del_buf: [id]
        }
  @type id :: pos_integer() | {pos_integer(), :ack}
  @type log_entry ::
          {:add, Queue.message()}
          | {:get, Queue.ack_id(), Queue.message()}
          | {:ack, Queue.ack_id()}
          | {:reject, Queue.ack_id(), Queue.message()}

  @spec sync(t) :: t
  def sync(wal = %{dets: dets, insert_buf: insert_buf, del_buf: del_buf, next_ack_id: next_ack_id}) do
    Enum.each del_buf, &(:ok = :dets.delete(dets, &1))

    :ok = :dets.insert(dets, Map.to_list(insert_buf))
    :ok = :dets.insert(dets, {:next_ack_id, next_ack_id})

    :ok = :dets.sync(dets)

    %{wal | insert_buf: %{}, del_buf: []}
  end

  @spec restore_queue(t, (pos_integer() -> Queue.t)) :: {t, Queue.t}
  def restore_queue(wal = %{dets: dets}, queue_init) do
    wal = sync(wal)
    
    active =
      dets
      # match pattern generated by: `:ets.fun2ms fn {{ack_id, :ack}, msg} -> {ack_id, msg} end`
      |> :dets.select([{{{:"$1", :ack}, :"$2"}, [], [{{:"$1", :"$2"}}]}])
      |> Enum.sort()

    next_ack_id = if Enum.empty?(active) do
      [{:next_ack_id, next_ack_id}] = :dets.lookup(dets, :next_ack_id)
      next_ack_id
    else
      active |> List.first() |> elem(0)
    end

    queue = Enum.reduce active, queue_init.(next_ack_id), fn {ack_id, msg}, q ->
      {:ok, q} = Queue.add(q, msg)
      {:ok, q, ^ack_id, _} = Queue.get(q)
      q
    end

    queue = dets
    # match pattern generated by: `:ets.fun2ms fn {id, msg} when is_integer(id) -> {id, msg} end`
    |> :dets.select([{{:"$1", :"$2"}, [is_integer: :"$1"], [{{:"$1", :"$2"}}]}])
    |> Enum.sort()
    |> Enum.reduce(queue, fn {_, msg}, q ->
      {:ok, q} = Queue.add(q, msg)
      q
    end)

    {wal, queue}
  end

  @spec log(t, log_entry) :: t
  def log(wal, entry)

  def log(wal = %{right_id: id, insert_buf: insert_buf}, {:add, message}) do
    %{wal | right_id: id + 1, insert_buf: Map.put(insert_buf, id, message)}
  end

  def log(
        wal = %{left_id: id, insert_buf: insert_buf, del_buf: del_buf},
        {:get, ack_id, message}
      ) do
    %{
      wal
      | left_id: id + 1,
        insert_buf: insert_buf |> Map.delete(id) |> Map.put({ack_id, :ack}, message),
        del_buf: [id | del_buf],
        next_ack_id: ack_id + 1
    }
  end

  def log(wal = %{insert_buf: insert_buf, del_buf: del_buf}, {:ack, ack_id}) do
    id = {ack_id, :ack}

    %{wal | insert_buf: Map.delete(insert_buf, id), del_buf: [id | del_buf]}
  end

  def log(wal, {:reject, ack_id, message}) do
    wal
    |> log({:ack, ack_id})
    |> log({:add, message})
  end
end
